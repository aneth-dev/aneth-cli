#!/bin/bash
# Depends:
# bin: bash cat sed(GNU) grep man groff
# debian: bash coreutils grep man-db groff-base

NAME=$(basename $0)
declare -gr KEYS=$(echo lang title version reference keywords resume description author{,s} copyright copyleft licen{c,s}e)
declare -A I18N_en
for _ in ${KEYS} manual name synopsis command{,s} option{,s}; do
	I18N_en[$_]=$_
done
I18N_en[colon]=': '
I18N_en[semicolon]='; '

declare -A I18N_fr=(
[manual]=manuel
[name]=nom
[synopsis]=synopsis
[description]=description
[commands]=commandes
[options]=options
[colon]=' : '
[semicolon]=' ; '
[author]=auteur
[authors]=auteurs
)
declare -n I18N

__init__() {
	. <(init -- $@ <<-\
		_EOF_
			#NAME: ads
			#TITLE: ADS Manual
			#VERSION: 1.0
			#RESUME: Auto documented script.
			#DESCRIPTION: _ADS_ permit script using it to be self and automatically documented. This tool permit to generate code to initializing options command line and add a _help_ which generates one in the manpage format.
			#AUTHOR: Thomas PÃ©rennou <thomas.perennou@aeten.net>
			#LICENCE: GLPv3
			#COPYLEFT: Thomas PÃ©rennou
			@init: Initialize a shell script from _stdin_. A shell script must call it like _source <(${NAME} init [<args>] -- \$@ <EOF [â€¦] EOF)_.
			 	?prefix NAME: Prefixes all generated variables by _NAME\__ (note the underscore after _NAME_).
			 	?posix|P: Select this option to generate POSIX shell code. Do not use associative array for parameters in the form of _param_=_value_.
			 	?writable: Unlock write variables protection.

			 	?left-header-logo| /logo: Logo to use at left header for PDF manual.
			 	?right-header-logo| /logo: Logo to use at right header for PDF manual.
			 	?center-header-logo| /logo: Logo to use at center header for PDF manual.
			 	?first-page-header| /image: Image to use as header of the first page for PDF manual.
			 	?style-section| none|highlight|underline: Defines the style of the titles of sections.
			 	?style-subsection| none|highlight|underline: Defines the style of the titles of sections.
			 	?primary-color| rgb: Primary color. Can retrieved from _first-page-header_ with Image Magik's _covert_ command. See colors section below.
			 	?secondary-color| rgb: Secondary color. See colors section below.
			 	?banner-header|B: Highlights header with _primary color_.
			 	?perseved-color|: Using persived luminance instead of linear RGB algorithm.
			@bash-completion executable: Generates Bash completion for an _executable_ supporting ${NAME}.
			@manual executable: Generates document on the standard output according to the given _format_ option.
			 	?format pdf|manpage|man|markdown|md|grofftty: Document generation _format_.
			 	?output /file: Output _file_ destination. The default is the name of executable with the appropriate extension in the current directory.
		#COLORS: The format must be in hexadecimal RGB like `#A1234B`.
		_EOF_
	)
	${ADS} $@
}

# {{{ init
init() {
	local _argc=$#
	local  _opt _option_level _option_command _command _option _COMMAND _OPTION _option2 _OPTION2 _requiered _multi _occurence _name _alias _ads_name _k
	local -n _cmd
	local _spaces=$'[ \t]'
	local -i _level=0
	local IFS

	while [ $# -ne 0 ]; do
		case "$1" in
			 -)           ADS_INPUT_FILE=/dev/stdin;;
			 --)          shift; break;;
			 *)           break;;
		esac
		shift
	done

	_name=$(basename $(readlink -f ${0}))
	if [[ ${_name} =~ ^(aeten-)?ads$ ]]; then
		_name=$(basename $(ps -p $PPID -o comm=))
	fi

	declare -gr ADS_CALLER=${_name}
	_name=${_name^^}
	_name=${_name//[. ]/_}

	declare -gr ADS_INPUT=$(sed 's/^ \+//' ${ADS_INPUT_FILE:-/dev/stdin}|__filter_input)
	declare -gA ADS_OPT
	declare -ga ADS_CMDID=(0)
	declare -gA ADS_CMD=([${ADS_CMDID}]=ADS_CMD_0)
	declare -gA ADS_CMD_0=(
		[0]=
		[id]=
		[name]="${ADS_CALLER}"
		[NAME]="${_name}"
		[value]=
		[requiered]=false
		[multi]=false
		[description]=
		[options]=
	)
	__add_help ${ADS_CMD[${ADS_CMDID}]}

	IFS=$'\n'
	for _opt in ${ADS_INPUT}; do
		unset ISF
		[ -z "${_opt}" ] && continue
		if [[ ${_opt} =~ ^$'\t'* ]]; then
			_option_level=${#BASH_REMATCH[0]}
		else # Should not occure
			continue
		fi
		if [[ ${_opt} =~ ^#([a-zA-Z0-9 -]+)${_spaces}*:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			ADS_CMD_0[${BASH_REMATCH[1],,}]=${BASH_REMATCH[3]}
		elif [[ ${_opt} =~ ^($'\t'{$_option_level})@([a-zA-Z0-9-]+)(${_spaces}+([!+*?]?)([][()=|_/a-zA-Z0-9.+*!?\\^\$-]+))?:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			if ((${_option_level} == 0)); then
				_option_command=${BASH_REMATCH[2]}
			elif ((${_option_level} > ${_level})); then
				_option_command=${_command}.${BASH_REMATCH[2]}
			else
				_command=${_command%.*}
				until ((${_option_level} == ${_level})); do
					command=${_command%.*}
					let _level--
				done
				_option_command=${_command}.${BASH_REMATCH[2]}
			fi
			_level=${_option_level}
			_command=${_option_command}
			_description=${BASH_REMATCH[7]}
			_occurence=${BASH_REMATCH[4]}
			case "${_occurence}" in
				   '?') _requiered=false; _multi=false;;
				   '*') _requiered=false; _multi=true;;
				   '+') _requiered=true;  _multi=true;;
				''|'!') _requiered=true;  _multi=false;;
			esac
			_COMMAND=ADS_CMD_${_command^^}
			_COMMAND=${_COMMAND//[.-]/_}
			ADS_CMDID+=(${_command})
			ADS_CMD[${_command}]=${_COMMAND}
			declare -gA ${_COMMAND}
			local -n _CMD=${_COMMAND}
			_CMD=(
				[id]=${_command}
				[name]=${BASH_REMATCH[2]}
				[value]=${BASH_REMATCH[5]}
				[requiered]=${_requiered}
				[multi]=${_multi}
				[description]=${BASH_REMATCH[7]}
				[options]=
			)
		elif (( ${_option_level} == 0 )); then
			_option_command=
			_command=
			_level=0
		elif ((${_option_level} > ${_level})); then
			_option_command=
			_level=$((${_option_level}-1))
		else
			_option_command=
			_command=${_command%.*}
			until ((${_option_level} == ${_level})); do
				_command=${_command%.*}
				let _level--
			done
			let _level--
		fi
		#                            1(occur) 2(name)        3  4(alias)        5           6(constraint)           7                                     8(description)
		if [[ ${_opt} =~ ^${_spaces}*([!+*?]?)([a-zA-Z0-9-]+)(\|([a-zA-Z0-9])?)?(${_spaces}+([!:|@_/a-zA-Z0-9-]+))?:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			_option=$(__join . ${_command} ${BASH_REMATCH[2]})
			_OPTION=${_option^^}
			_OPTION=ADS_OPT_${_OPTION//[.-]/_}
			_occurence=${BASH_REMATCH[1]}
			case "${_occurence}" in
				''|'?') _requiered=false; _multi=false;;
				   '*') _requiered=false; _multi=true;;
				   '+') _requiered=true;  _multi=true;;
				   '!') _requiered=true;  _multi=false;;
			esac
			_name=${BASH_REMATCH[2]}
			_alias=${BASH_REMATCH[4]}
			((${#_alias} == 0)) && [[ ${BASH_REMATCH[3]} != '|' ]] && _alias=${_name:0:1}
			if ((${#_command} == 0)); then
				_COMMAND=ADS_CMD_0
			else
				_COMMAND=${_command^^}
				_COMMAND=ADS_CMD_${_COMMAND//[.-]/_}
			fi
			declare -gA ${_OPTION}
			local -n _OPT=${_OPTION}
			_OPT=(
				[0]=
				[id]=${_option}
				[name]=${_name}
				[alias]=${_alias}
				[value]=${BASH_REMATCH[6]}
				[command]=${_command}
				[requiered]=${_requiered}
				[multi]=${_multi}
				[description]=${BASH_REMATCH[8]}
			)
			local -n _CMD=${_COMMAND}
			_CMD[options]+=" ${_option}|${_alias}"
			ADS_OPT[${_option}]=${_OPTION}
			# Add alias
			_option2=$(__join . ${_command} ${_alias})
			_OPTION2=ADS_OPT[${_option2}]
			if ! declare -p "${!_OPTION2}" >& /dev/null; then
				ADS_OPT[${_option}]=${_OPTION}
			elif [[ ${DEBUG} = yes ]]; then
				echo "[WARNING] While processing option alias ${_alias} for option ${_alias} (already taken by ${_OPTION2[id]})" >&2
			fi
		fi
	done
	unset IFS
	ADS_CMD_0[NAME]="${ADS_CMD_0[name]^^}"
	ADS_CMD_0[NAME]="${ADS_CMD_0[NAME]//[-.]/_}"
	if [[ -z ${ADS_CMD_0[lang]} ]]; then
		I18N=I18N_en
	else
		I18N=I18N_${ADS_CMD_0[lang]}
		for _k in ${!I18N_en[@]}; do
			: ${I18N[$_k]:=${I18N_en[$_k]}}
		done
	fi

	case ${ADS_DEBUG:-false} in
		verbose|true) exec > >(tee -i /dev/stderr);;
	esac
	__init $@
}

__init() {
	local _name _cmd _opt

	if ${ADS_INITILIZED:-false}; then
		case ${ADS_DEBUG:-false} in
			verbose) set -x;&
			true)    for _cmd in ${ADS_CMDID[@]}; do
			         	__debug_command ${ADS_CMD[${_cmd}]}
			         done;;
		esac
	fi

	declare -ga ADS_ARGV=($@)
	__parse_cmdline \
		--cmdline-pre-hook  __pre_init \
		--cmdline-post-hook __post_init \
		--cmd-post-hook     __cmd_init \
		--opt-hook          __opt_init \
		--cmd-error-hook    __cmd_error \
		--opt-error-hook    __opt_error \
		-- $@
}

__add_command() {
	local _id=$1
	local _description=$2

	local _name=${_id##*.}
	local _varname=${_id^^}
	_varname=ADS_OPT_${_varname//[.-]/_}
	declare -gA ${_varname}
	local -n _cmd=${_varname}
	_cmd=(
		[0]=
		[id]=${_id}
		[name]=${_name}
		[value]=
		[requiered]=false
		[multi]=false
		[description]=${_description}
		[options]=
	)
	ADS_CMDID+=(${_id})
	ADS_CMD[${_id}]=${_varname}
}

__add_help() {
	local -n _cmd=$1

	local _optname=$(__join _ ${_cmd[id]^^} HELP)
	_optname=ADS_OPT_${_optname//[.-]/_}
	declare -gA ${_optname}
	local -n _option=${_optname}
	_option[0]=
	_option[id]=$(__join . ${_cmd[id]} help)
	_option[name]=help
	_option[alias]=h
	_option[value]=
	_option[command]=${_cmd[id]}
	_option[requiered]=false
	_option[multi]=false
	_option[description]="Print _${_cmd[name]}_ help."
	ADS_OPT[${_option[id]}]=${_optname}
	_cmd[options]+=" ${_option[id]}|h"
}

__help() {
	__groff|man -l - >&2
	echo exit 0
}

__usage() {
	local _msg _cmd
	while [ $# -ne 0 ]; do
		case "$1" in
			--command|-c) shift; _cmd=$1 ;;
			--)           shift; break;;
			 *)           break;;
		esac
		shift
	done

	if (( ${#@} > 0 )); then
		_msg=$(echo "$@"|__filter_input|__groff_inline_style)$'\n.SH Usage:'
	else
		_msg='.SH Usage: '
	fi
	groff -Kutf8 -Tutf8 -man <<-EOF | sed '/^\s*$/d;/\s*()/d;/()\s*()/d'
		.TH
		${_msg}
		$(__groff_synopsis ${_cmd})
	EOF
}

# }}} init

# {{{ commands
manual() {
	local _format=${MANUAL_FORMAT:-pdf}
	local _output
	if [[ -z ${MANUAL_OUTPUT} ]]; then
		_output=$(basename ${MANUAL_EXECUTABLE})
		_output=./${_output%%.*}.${_format}
	else
		if [[ ${MANUAL_OUTPUT} == /dev/stdout ]]; then
			_output=/proc/$$/fd/1
		else
			_output=${MANUAL_OUTPUT}
		fi
	fi
	"${MANUAL_EXECUTABLE}" __ads__ ${_format} "${_output}"
}

bash-completion() {
	"${BASH_COMPLETION_EXECUTABLE}" __ads__ bash-completion
}
# }}} commands

# {{{ cmdline
__parse_cmdline() {
	local _cmdline_pre_hook _cmdline_post_hook _cmd_pre_hook _cmd_post_hook _opt_hook
	local _i _argc _argv _id _varname _cmdid _cmd _opt _command _found

	while [ $# -ne 0 ]; do
		case "$1" in
			--cmd-pre-hook)      _cmd_pre_hook=$2; shift;;
			--cmd-post-hook)     _cmd_post_hook=$2; shift;;
			--cmdline-pre-hook)  _cmdline_pre_hook=$2; shift;;
			--cmdline-post-hook) _cmdline_post_hook=$2; shift;;
			--opt-hook)          _opt_hook=$2; shift;;
			--cmd-error-hook)    _cmd_error_hook=$2; shift;;
			--opt-error-hook)    _opt_error_hook=$2; shift;;
			--)                  shift; break;;
			 *)                  break;;
		esac
		shift
	done
	_argc=$#

	if declare -F "${_cmdline_pre_hook}" &>/dev/null; then
		${_cmdline_pre_hook}
	fi
	local -n _cmd=ADS_CMD_0
	while [ $# -ne 0 ]; do
		if [[ $1 = -- ]]; then
			shift
			break
		fi
		if [[ $1 =~ ^- ]]; then
			# Option
			local _alias _optname _found=false
			for _id in ${_cmd[options]}; do
				local -n _opt=${ADS_OPT[${_id%%|*}]}
				case $1 in
					--?*)  _optname=${1:2};;
					-[^-]) _optname=${1:1};;
					--)    shift; continue;;
				esac
				for _alias in ${_opt[name]} ${_opt[alias]//|/ }; do
					if [[ ${_optname} == ${_alias} ]]; then
						if (( ${#_opt[value]} == 0 )); then
							_opt=true
						else
							_opt=$2
							shift
						fi
						_found=true
						break
					fi
				done
			done
			if ! $_found && declare -F "${_opt_error_hook}" &>/dev/null; then
				echo ${!_cmd} >&2
				declare -p ${!_cmd} >&2
				${_opt_error_hook} "${_cmdid}" "$1"
			fi
		else
			# Command
			_id=$(__join . ${_cmdid} $1)
			_varname=${ADS_CMD[${_id}]}
			if declare -p "${_varname}" &>/dev/null; then
				local -n _cmd=${ADS_CMD[${_id}]}
				_cmdid=${_id}
				shift
				if (( ${#_cmd[value]} == 0 ));then
					_cmd=true
				else
					let _i=0
					until [ $# -eq 0 ] || [[ $1 =~ ^-.$ ]] || [[ $1 =~ ^--[^-].*$ ]]; do
						_cmd[0]+="\$'${1//\'/\\\'}' "
						shift
					done
				fi
				continue
			elif (( ${#_cmd[value]} > 0 )); then
				let _i=0
				until [ $# -eq 0 ] || [[ $1 =~ ^-.$ ]] || [[ $1 =~ ^--[^-].*$ ]]; do
					_cmd[0]+="\$'${1//\'/\\\'}' "
					shift
				done
				continue
			elif declare -F "${_cmd_error_hook}" &>/dev/null; then
				${_cmd_error_hook} "${_id}"
			fi
		fi

		shift
	done
	local -n _command=${!_cmd}

	for _id in ${ADS_CMDID[@]}; do
		local -n _cmd=${ADS_CMD[${_id}]}
		if declare -F "${_cmd_pre_hook}" &>/dev/null; then
			${_cmd_pre_hook} ${!_cmd}
		fi
		for _id in ${_cmd[options]}; do
			local -n _opt=${ADS_OPT[${_id%%|*}]}
			if (( ${#_opt[value]} == 0 )) && (( ${#_opt} == 0 )); then
				_opt=false
			fi
			if declare -F "${_opt_hook}" &>/dev/null; then
				${_opt_hook} ${!_opt} ${!_command}
			fi
		done
		if declare -F "${_cmd_post_hook}" &>/dev/null; then
			${_cmd_post_hook} ${!_cmd}
		fi
	done

	let _argc=${_argc}-$#
	if declare -F "${_cmdline_post_hook}" &>/dev/null; then
		if declare -p "${!_command}" &>/dev/null; then
			${_cmdline_post_hook} ${!_command} ${_argc}
		else
			${_cmdline_post_hook} ${ADS_CMD} ${_argc}
		fi
	fi
}

__pre_init() {
	cat - <<-EOF
		__ads_heredoc() {
			cat - <<-_BEOF_
				${ADS_INPUT}
			_BEOF_
		}

		${INIT_PREFIX,,}usage() {
			local _msg
			local errno=1
			while [ \$# -ne 0 ]; do
				case "\$1" in
					--errno)      errno=\$2; shift;;
					--)           shift; break;;
					 *)           break;;
				esac
				shift
			done
			__ads_heredoc|"\$0" __ads__ usage -- ${ADS_CMD_0[name]}: \$@ >/dev/\$( [ "\${errno}" = 0 ] && echo stdout || echo stderr)
			exit \${errno}
		}
	EOF
}

__cmd_init() {
	true
}

__check_value() {
	local _element_type=$1
	local _element_id=$2
	local _value=$3
	local _constraint=$4

	case ${_constraint} in
		'') ;;
		/*/) [[ -d $_v ]] || {
			echo "Directory for ${_element_type} '${_element_id//./ }' must exists." >&2
			echo exit 1
			exit 0
		} ;;
		/*) [[ -r $_value ]] || {
			echo "File for ${_element_type} '${_element_id//./ }' must exists and be readable." >&2
			echo exit 1
			exit 0
		} ;;
		*) [[ ${_value} =~ ^${_constraint//|/$|^}$ ]] || {
			echo "Value for ${_element_type} '${_element_id//./ }' must match $_constraint." >&2
			echo exit 1
			exit 0
		} ;;
	esac
}

__init_value_definition() {
	local -n _p=$1
	local _definition=$2
	#                        key=value
	#                        key(key constraint)=value(value constraint)
	#                        1       2  3        4       5  6
	if [[ ${_definition} =~ ^([^\(]*)(\((.+)\))?=([^\(]*)(\((.+)\))?$ ]]; then
		_p[key.name]=${BASH_REMATCH[1]}
		_p[key.constraint]=${BASH_REMATCH[3]}
		_p[name]=${BASH_REMATCH[4]}
		_p[constraint]=${BASH_REMATCH[6]}
	#                          value
	#                          value(value constraint)
	#                          1      2   3
	elif [[ ${_definition} =~ ^([^\(]+)(\((.+)\))?$ ]]; then
		_p[name]=${BASH_REMATCH[1]}
		_p[constraint]=${BASH_REMATCH[3]}
	fi
	case ${_p[name]} in
		/*/) _p[type]=directory; _p[name]=${_p[name]:1:${#_p[name]}-2};;
		/*)  _p[type]=file;      _p[name]=${_p[name]:1};;
	esac
}

__post_init() {
	local -n _cmd=$1
	local _shift=$2
	local _k _v _param _access
	local _varname=${_cmd[id]^^}
	if [[ ${!_cmd} == ADS_CMD_0 ]]; then
		_varname=${INIT_PREFIX}${ADS_CMD_0[NAME]}
	else
		_varname=${INIT_PREFIX}${_varname//[.-]/_}
	fi
	eval local -a _value=($_cmd)

	local -A _param
	__init_value_definition _param ${_cmd[value]}

	if (( ${#_value} == 0 )) && (( ${#_param[key.name]} == 0 )); then
		case ${_param[constraint]} in
			/*/) _value[0]=./ ;;
			/*)  _value[0]=-;;
		esac
	fi

	_cmd=
	for _v in ${_value[@]}; do
		if (( ${#_param[key.name]} > 0 )); then # Associative array
			_k=${_v%%=*}
			_v=${_v#*=}
			if (( ${#_param[key.constraint]} > 0 )); then
				__check_value "command '${_cmd[id]//./ }' parameter name" "${_param[key.name]}" "$_k" "${_param[key.constraint]}"
			fi
		fi
		case ${_param[type]} in
			directory) if [[ -z ${_v} ]] && ${_cmd[requiered]}; then _v=./;fi;;
			file)      if [[ ${_v} =~ ^-$|^$ ]]; then ${_cmd[requiered]} && _v=/dev/stdin || _v=/dev/stdout; fi;;
		esac
		if [[ ${_v} =~ ^-$|^$ ]]; then
			case ${_cmd[value]} in
				/*/) ${_cmd[requiered]} || _v=./ ;;
				/*)  ${_cmd[requiered]} && _v=/dev/stdin || _v=/dev/stdout ;;
			esac
		fi
		if (( ${#_param[key.name]} > 0 )); then # Associative array
			_cmd[0]+="[\$'${_k//\'/\\\'}']=\$'${_v//\'/\\\'}' "
		else
			_cmd[0]+="\$'${_v//\'/\\\'}' "
		fi
		if (( ${#_param[constraint]} > 0 )); then
			__check_value "command '${_cmd[id]//./ }' parameter value" "${_param[name]}" "$_v" "${_param[constraint]}"
		fi
	done

	if ${_cmd[multi]} && ${_cmd[requiered]} && (( ${#_value[@]} == 0 )); then
		echo "There must be at least one value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	elif ${_cmd[requiered]} && (( ${#_value[@]} == 0 )); then
		echo "There must be a value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	elif ! ${_cmd[multi]} && (( ${#_value[@]} > 1 )); then
		echo "There must be only one value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	fi

	if ! ${INIT_WRITABLE:-false}; then
		_access=r
	fi
	if (( ${#_cmd[value]} > 0 )); then
		_varname=${_varname}_${_param[name]^^}
		_varname=${_varname//[.-]/_}
		if (( ${#_param[key.name]} > 0 )); then # Associative array
			if ${INIT_POSIX}; then
				eval _param=(${_cmd})
				for _k in ${!_param[@]}; do
					echo "declare -g${_access} ${_varname}_${_k^^}=${_param[$_k]}"
				done
			else
				echo "declare -g${_access}A ${_varname}=(${_cmd})"
			fi
		elif ${_cmd[multi]}; then
			echo "declare -g${_access}a ${_varname}=(${_cmd})"
		else
			echo "declare -g${_access} ${_varname}=${_cmd}"
		fi
	fi

	if ${ADS_OPT_HELP:-false}; then
		__help
	elif (( ${#ADS_CMD[@]} > 1 )) && [[ ${!_cmd} == ADS_CMD_0 ]]; then
		__usage ${_cmd[name]}: Missing command>&2
	else
		cat - <<-EOF
			declare -g${_access} ${INIT_PREFIX}${ADS_CMD_0[NAME]}=${_cmd[id]}
			shift $_shift
		EOF
	fi
}

__opt_init() {
	local -n _opt=$1
	local -n _selected_cmd=$2
	local _varname=${_opt[id]^^}
	_varname=${INIT_PREFIX}${_varname//[.-]/_}
	local _access
	if ! ${INIT_WRITABLE:-false}; then
		_access=r
	fi

	if (( ${#_opt} > 0 )); then
		case ${_opt[value]} in
			!/*/)   [[ -d $_opt ]] || {
				echo Directory for option --${_opt[name]} must exists. >&2
				echo exit 1
			} ;;
			!/*)    if [[ $_opt == - ]]; then _opt=/dev/stdin; else [[ -r $_opt ]] || {
				echo File for option --${_opt[name]} must exists and be readable. >&2
				echo exit 1
			}; fi ;;
			?/*|/*) if [[ $_opt == - ]]; then _opt=/dev/stdout; fi; >&2;;
			*\|*)   [[ ${_opt} =~ ^${_opt[value]}$ ]] || {
				echo Value for option --${_opt[name]} must be one of ${_opt[value]}. >&2
				echo exit 1
			} ;;
		esac
		echo "declare -g${_access} ${_varname}='${_opt}'"
	elif [[ ${_opt[command]} == ${_selected_cmd[id]} ]] && ${_opt[requiered]}; then
		__usage --command ${_selected_cmd[id]} "Option --${_opt[name]} is requiered." >&2
		echo exit 1
	fi
}

__cmd_error() {
	local _cmd=${ADS_CMD_0[name]}.$1
	_cmd=${_cmd%.*}
	case $1 in
		__ads__) _cmdid=$1;;
		__ads__.usage)    echo exit 0; __usage ${ADS_ARGV[@]:2}; exit $?;;
		__ads__.grofftty) echo exit 0; __groff | groff -Kutf8 -Tutf8 -man - >${ADS_ARGV[2]}; exit $?;;
		__ads__.pdf)      echo exit 0; __groff true | groff -Kutf8 -U -dpaper=a4 -P-pa4 -Tpdf -mpdfmark -t -man - >${ADS_ARGV[2]}; exit $?;;
		__ads__.manpage)  ;&
		__ads__.man)      echo exit 0; __groff true >${ADS_ARGV[2]}; exit $?;;
		__ads__.markdown) ;&
		__ads__.md) echo exit 0; echo ${ADS_ARGV[2]}>&2; __markdown >${ADS_ARGV[2]}; exit $?;;
		__ads__.bash-completion) echo exit 0; __ads_heredoc|__bash-completion >${ADS_ARGV[2]}; exit $?;;
		*)
			__usage --command "${1%.*}\..*" "${ADS_CMD_0[name]}: '${1##*.}' is not a '${_cmd//./ }' command. See '${ADS_CMD_0[name]} --help'." >&2
			echo exit 1
			exit 0
		;;
	esac
}

__opt_error() {
	local _cmd=$1 _opt=$2
	__usage --command "${_cmd}(\..*)?" "${ADS_CMD_0[name]}: '${_opt}' is not a ${ADS_CMD_0[name]} ${_cmd//./ } option. See '${ADS_CMD_0[name]} --help'." >&2
	echo exit 1
	exit 0
}
# }}} cmdline

__is_dark() {
	local _color=${*// /} # %02x%02x%02x r g b
	if ${INIT_PERSEVED_COLOR:=false}; then
		(( ((299 * 16#${_color:0:2} + 587 * 16#${_color:2:2} + 114 * 16#${_color:4:2}) / (1000)) < 128 ))
	else
		(( ((2126 * 16#${_color:0:2} + 7152 * 16#${_color:2:2} + 0722 * 16#${_color:4:2}) / (10000)) < 128 ))
	fi
}

# {{{ groff
__groff() {
	local _pdf=$1
	local _cmd _id _value
	local _has_header_logo
	local _first_page_header_dimentions _first_page_header_height # cm
	local _color # %02x%02x%02x r g b
	local _luminance # %02x%02x%02x r g b

	if [[ ${_pdf} = true ]]; then
		if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
			_first_page_header_dimentions=$(pdfinfo "${INIT_FIRST_PAGE_HEADER}"| sed -n 's/Page *size: *\([[:digit:].]*\) *x *\([[:digit:].]*\).*$/\1x\2/p')
			_first_page_header_height=$(( 21*${_first_page_header_dimentions#*x}/${_first_page_header_dimentions%x*} ))c
			: ${INIT_PRIMARY_COLOR:=#$(convert "${INIT_FIRST_PAGE_HEADER}" -flatten +dither -colors 2 -unique-colors -depth 8 -alpha off -format "%[hex:u]\\n" info:)}
		fi
		: ${INIT_SECONDARY_COLOR:=${INIT_PRIMARY_COLOR}}
		cat - <<-EOF
			.TH "${ADS_CMD_0[name]^}" 1 "${ADS_CMD_0[reference]} - $(date +%D)" "${ADS_CMD_0[name]^} ${ADS_CMD_0[version]}" "${ADS_CMD_0[section]}"
			.RP
			.nr PO 2c
			.nr IN 1c
			.nr LL 17c
			.nr LT 17c
			.nr PS 0.4c
			.nr PS-SS 0.4c
			.nr PS-SH 0.5c
			.nr VS 0.5c
			.nr SN 0.5c
			.de highlight-TH
				\\h'-4c'\\M[banner-header-bg]\\D'P 0 (u;-\\\\n[.v]) 23c 0 0 (u;\\\\n[.v])'\\h'-19c'\\M[]
			.	sp (u;-(\\\\n[.v]/2+\\\\n[.s])
			..
		EOF
		if ${INIT_BANNER_HEADER:false}; then
			if __is_dark ${INIT_PRIMARY_COLOR#*#}; then
				cat - <<-EOF
					.defcolor banner-header-fg rgb #ffffff
					.defcolor banner-header-bg rgb ${INIT_PRIMARY_COLOR}
				EOF
			else
				cat - <<-EOF
					.defcolor banner-header-fg rgb #000000
					.defcolor banner-header-bg rgb ${INIT_PRIMARY_COLOR}
				EOF
			fi
		else
			if __is_dark ${INIT_PRIMARY_COLOR#*#}; then
				cat - <<-EOF
					.defcolor banner-header-fg rgb ${INIT_PRIMARY_COLOR}
					.defcolor banner-header-bg rgb #ffffff
				EOF
			else
				cat - <<-EOF
					.defcolor banner-header-fg rgb #000000
					.defcolor banner-header-bg rgb #ffffff
				EOF
			fi
		fi
		if [[ ${INIT_STYLE_SECTION} = highlight ]]; then
			if __is_dark ${INIT_PRIMARY_COLOR#*#}; then
				cat - <<-EOF
					.defcolor section-fg rgb #ffffff
					.defcolor section-bg rgb ${INIT_PRIMARY_COLOR}
				EOF
			else
				cat - <<-EOF
					.defcolor section-fg rgb #000000
					.defcolor section-bg rgb ${INIT_PRIMARY_COLOR}
				EOF
			fi
		else
			cat - <<-EOF
				.defcolor section-fg rgb ${INIT_PRIMARY_COLOR}
				.defcolor section-bg rgb #ffffff
			EOF
		fi
		if [[ ${INIT_STYLE_SUBSECTION} = highlight ]]; then
			if __is_dark ${INIT_SECONDARY_COLOR#*#}; then
				cat - <<-EOF
					.defcolor subsection-fg rgb #ffffff
					.defcolor subsection-bg rgb ${INIT_SECONDARY_COLOR}
				EOF
			else
				cat - <<-EOF
					.defcolor subsection-fg rgb #000000
					.defcolor subsection-bg rgb ${INIT_SECONDARY_COLOR}
				EOF
			fi
		else
			cat - <<-EOF
				.defcolor subsection-fg rgb #000000
				.defcolor subsection-bg rgb #ffffff
			EOF
		fi
		case ${INIT_STYLE_SECTION:none} in
			highlight)
				cat - <<-EOF
					.de highlight-SH
						\\h'-4c'\\M[section-bg]\\D'P 0 (u;-\\\\n[.v]) 23c 0 0 (u;\\\\n[.v])'\\h'-19c'\\M[]
					.	sp (u;-(\\\\n[.v]/2+\\\\n[.s])
					..
				EOF
			;;
			underline)
				cat - <<-EOF
					.de highlight-SH
						\\h'-4c'\\M[section-bg]\\D'P 0 (u;\\\\n[.v]-2p) 23c 0 0 (u;\\\\n[.v])'\\h'-19c'\\M[]
					.	sp (u;-(\\\\n[.v]/2+\\\\n[.s])
					..
				EOF
			;&
			*)
				cat - <<-EOF
					.de highlight-SH
					..
				EOF
			;;
		esac
		cat - <<-EOF
			$(if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
				cat - <<-HEADER
					.rn an-header an-header-orig
					.de1 an-header
					.if (2=\\\\n[.pn]) \\{
					.	rs
					.	po 0
					.	vs 0
					.	sp |0
						\\X'pdf: pdfpic ${INIT_FIRST_PAGE_HEADER} -L 21c'
					.	sp 0
					.	vs
					.	po
					\\}
					.	an-header-orig
					.	sp |${_first_page_header_height}
					..
				HEADER
			else
				cat - <<-HEADER
				HEADER
			fi)
			.de1 PT
			.	fam H
			$(if [[ -n ${INIT_LEFT_HEADER_LOGO} ]] || [[ -n ${INIT_CENTER_HEADER_LOGO} ]] || [[ -n ${INIT_RIGHT_HEADER_LOGO} ]]; then
				cat - <<-LOGO_EOF
					$(if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
						echo '.if (\\n[.pn]>2) \{'
					else echo .
					fi)
					.	vs 0
					.	sp |0.4c
					 $([[ -n ${INIT_LEFT_HEADER_LOGO} ]] && echo "\X'pdf: pdfpic ${INIT_LEFT_HEADER_LOGO} -L 0 1.2c'" || echo .)
					$([[ -n ${INIT_CENTER_HEADER_LOGO} ]] && echo "\X'pdf: pdfpic ${INIT_CENTER_HEADER_LOGO} -C 0 1.2c 21c'" || echo .)
					$([[ -n ${INIT_RIGHT_HEADER_LOGO} ]] && echo "\X'pdf: pdfpic ${INIT_RIGHT_HEADER_LOGO} -R 0 1.2c 19c'" || echo .)
					.sp 2.8c
					$(if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
						echo '\}'
					else echo .
					fi)
				LOGO_EOF
			else
				$(if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
					cat - <<-HEADER
						.vs 0
						.sp |0
						.if (2=\\\\n[.pn]) \X'pdf: pdfpic ${INIT_FIRST_PAGE_HEADER} -L 21c'
					HEADER
				else echo .
				fi)
			fi)
			.	fam H
			.	vs 0
			.	ps \\n[PS-SH]
			.	nr margin \\n[PS-SH]
			.	vs (u;\\n[PS-SH]+(2*\\\\n[margin]))
			.	ie (\\\\n[.pn]=2) .sp |0
			.	el .sp |(1.6c)
			.	ie (\\\\n[.pn]=2) .sp \\\\n[margin]u
			.	el .if '${INIT_BANNER_HEADER}'true' .highlight-TH
			.	ns
			.	vs
			.	ps
			.	ie (\\\\n[.pn]=2) \{
			.		ie '${INIT_BANNER_HEADER}'true' \\m[banner-header-fg]
			.		el \\m[banner-header-bg]
				\}
			.	el \\m[banner-header-fg]
			.	tl %\\\\*[an-title](\\\\*[an-section])%\\s[\\n[PS-SH]u]\\fB\\\\*[an-extra3]\\fR\\s[\\n[PS]u]%\\\\*[an-title](\\\\*[an-section])\\x'-\\\\n[margin]u'\\x'(u;\\\\n[margin]*2)'%
			.	\\m[]
			.	if (\\\\n[.pn]>1) .sp 0
			.	ns
			..
			.
			.rn SH SH-orig
			.de SH
			.	rs
			.	sp 1v
			.	ps \\n[PS-SH]
			.	vs (u;\\n[PS-SH]*2)
			.	highlight-SH
			.	vs
			.	ns
			.	SH-orig \\m[section-fg]\\\\\$*\\m[]
			.	set-an-margin
			.	nr IN 1c
			.	rs
			.	vs
			.	ll 17c
			.	sp 1v
			.	ns
			..
			.po \\n[PO]u
			.ll 17c
			.pdfinfo /Author ${ADS_CMD_0[author]} ${ADS_CMD_0[authors]}
			.pdfinfo /Subject ${ADS_CMD_0[name]} - ${ADS_CMD_0[resume]}
			.pdfinfo /Title ${ADS_CMD_0[title]}
			.pdfinfo /Keywords ${ADS_CMD_0[name]} ${I18N[manual]} ${ADS_CMD_0[keywords]}
			.pdfinfo /Creator aeten-ads
			.pdfinfo /Identifier ${ADS_CMD_0[reference]:=${ADS_CMD_0[name]}.${ADS_CMD_0[version]}}
			.pdfinfo /Version ${ADS_CMD_0[version]}
			.
			.fam H
			$(if [[ -n ${INIT_FIRST_PAGE_HEADER} ]]; then
				cat - <<-OFFSET
				OFFSET
			fi)
		EOF
	else
		cat - <<-EOF
			.TH "${ADS_CMD_0[name]^^}" 1 "$(date +%D)" "${ADS_CMD_0[name]^^} ${ADS_CMD_0[version]}" "${ADS_CMD_0[title]}"
		EOF
	fi
	cat - <<-EOF
		$(__groff_section ${I18N[name]})
		.NH 1 ${ADS_CMD_0[name]}
		.PP
			.in \\n[IN]u
		${ADS_CMD_0[name]} âˆ’ $(echo "${ADS_CMD_0[resume]}"|__groff_inline_style)
		$(__groff_section ${I18N[synopsis]})
		.
		$(__groff_synopsis)
		.fi
		$(__groff_section ${I18N[description]})
		$(echo "${ADS_CMD_0[description]}"|__groff_inline_style)
		$(if (( ${#ADS_CMDID[@]} > 1 )); then
			__groff_section ${I18N[commands]}
			for _id in ${ADS_CMDID[@]:1}; do
				local -n _cmd=${ADS_CMD[${_id}]}
				if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
					continue
				fi
				echo .ns
				echo -n ".SS \fB${ADS_CMD_0[name]}\\ ${_cmd[id]//./\\ } "
				for _id in ${_cmd[options]}; do
					 __groff_synopsis_opt ${ADS_OPT[${_id%%|*}]}
				done
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1      2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					echo "\\fI${BASH_REMATCH[1]}\\fR=\\fI${BASH_REMATCH[4]}\\fR"
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					_value=${BASH_REMATCH[1]#/}
					_value=${_value#\!/}
					_value=${_value%/}
					echo "\\fI${_value}\\fR"
				fi
				echo $'\n.fi\n.'
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1       2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo "\\fI${BASH_REMATCH[1]}\\fR${I18N[colon]}${BASH_REMATCH[3]//|/ | }"
						echo $'\n.fi\n.'
					fi
					if (( ${#BASH_REMATCH[6]} > 0 )); then
						echo "\\fI${BASH_REMATCH[4]}\\fR${I18N[colon]}${BASH_REMATCH[6]//|/ | }"
						echo $'\n.fi\n.'
					fi
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo $'\n.fi\n.'
						echo "\\fI${BASH_REMATCH[1]}\\fR${I18N[colon]}${BASH_REMATCH[3]//|/ | }"
						echo $'\n.fi\n.'
					fi
				fi
				[ "${_pdf}" = true ] && echo .sp -0.6v
				echo "${_cmd[description]}"|__groff_inline_style
				for _id in ${_cmd[options]}; do
					__groff_opt ${ADS_OPT[${_id%%|*}]}
					echo .sp -1
				done
				echo .sp
			done
			echo .sp
		fi)
		.sp -2
		$(__groff_section ${I18N[options]})
		$(for _id in ${ADS_CMD_0[options]}; do
			__groff_opt ${ADS_OPT[${_id%%|*}]}
			echo .sp -1
		done)
		$(for _id in "${!ADS_CMD_0[@]}"; do
			[[ "${KEYS} multi value 0 id requiered options name NAME" =~ ${_id} ]] && continue
			cat -<<-_EOF_
				$(__groff_section ${_id})
				$(echo "${ADS_CMD_0[$_id]}" | __groff_inline_style)
			_EOF_
		done)
		$(for _id in author authors copyright copyleft licence license; do
			[[ -z ${ADS_CMD_0[$_id]} ]] && continue
			cat -<<-_EOF_
				$(__groff_section ${I18N[${_id}]})
				$(echo "${ADS_CMD_0[$_id]}" | __groff_inline_style)
			_EOF_
		done)
	EOF
}

__groff_inline_style() {
	sed --regexp-extended 's/\\n/\n.br\n/g; s/\\_/\\(ul/g; s/\\\*/\\[u0042]/g; s/([^\]?)_([^_]+)_( )?/\1\\fI\2\\fR\3/g;s/([^\\])?\*([^*]+)\*( )?/\1\\fB\2\\fR\3/g; s/Â /\\[u00A0]/g; s/\\\[u0042\]/*/g; s/  / \\ /g'
}

__groff_section() {
	if [[ ${_pdf} = true ]]; then
		echo ".SH ${*^}"
	else
		echo ".SH ${*^^}"
	fi
}

__groff_synopsis() {
	local _id _value _command _cmdid=$1
	cat -<<-EOF
		.SY \\f[B]${ADS_CMD_0[name]}\\f[R]
		\\f[B]-h\\f[R]|\\f[B]--help
		.YS
		.sp -1n
		.SY \\f[B]${ADS_CMD_0[name]}\\f[R]
	EOF
	for _id in ${ADS_CMD_0[options]}; do
		[[ ${_id%%|*} = help ]] && continue
		__groff_synopsis_opt ${ADS_OPT[${_id%%|*}]}
	done
	if (( ${#ADS_CMDID[@]} > 1 )); then
		echo -n "\\f[I]${I18N[command]}\\f[R] [\\f[I]args\\f[R]]"
		echo $'\n.YS'
		for _id in ${ADS_CMDID[@]:1}; do
			if (( ${#_cmdid} > 0 )) && [[ ! ${_id} =~ ^${_cmdid}$ ]]; then
				continue
			fi
			local -n _cmd=${ADS_CMD[${_id}]}
			if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
				continue
			fi
			_command="${ADS_CMD_0[name]} ${_cmd[id]//./ }"
			echo -n $'.sp -1n\n.SY \\f[B]'"${_command// /\\ }\\f[R]"
			if (( ${#_cmd[options]} > 0 )) || (( ${#_cmd[value]} > 0 )); then
				echo
			fi
			for _id in ${_cmd[options]}; do
				__groff_synopsis_opt ${ADS_OPT[${_id%%|*}]}
			done
			#                        key=value
			#                        key(key constraint)=value(value constraint)
			#                        1      2  3        4      5  6
			if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
				_value=${BASH_REMATCH[4]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "\\f[I]${BASH_REMATCH[1]}\\f[R]=\\f[I]${_value}\\f[R]"
			#                          value
			#                          value(value constraint)
			#                          1      2  3
			elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
				_value=${BASH_REMATCH[1]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "\\f[I]${_value}\\f[R]"
			fi
			echo $'\n.YS'
		done
	fi
}

__groff_opt() {
	local -n _opt=$1
	local _value _formated_value _formated_alias
	_value=${_opt[value]}
	if [ -n "${_value}" ]; then
		_value=${_value#/}
		_value=${_value#\!/}
		_value=${_value%/}
		_formated_value="\\ \\f[I]${_value}"
	fi
	if [[ -n ${_opt[alias]} ]]; then
		_formated_alias=", \\f[B]\\-${_opt[alias]}\f[R]${_formated_value}"
	fi
	cat - <<-EOF
		.TP
		\\f[B]\\-\\-${_opt[name]}\\f[R]${_formated_value}\\f[R]${_formated_alias}
		\\f[R]$(echo "${_opt[description]}"|__groff_inline_style)
		.sp
	EOF
}

__groff_synopsis_opt() {
	local _value
	local -n _opt=$1
	_value=${_opt[value]}
	#                        key=value
	#                        key(key constraint)=value(value constraint)
	#                        1       2  3        4       5  6
	if [[ ${_opt[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}=${BASH_REMATCH[4]}
	#                          value
	#                          value(value constraint)
	#                          1      2  3
	elif [[ ${_opt[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}
	fi

	_value=${_value#/}
	_value=${_value#\!/}
	_value=${_value%/}
	if ${_opt[requiered]}; then
		printf '\\f[B]-%s\\f[R]|\\f[B]--%s %s\\f[R]\\ ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " \\f[I]${_value}")"
	else
		printf '\\f[R][\\f[B]-%s\\f[R]|\\f[B]--%s\\f[R]%s\\f[R]]\\ ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " \\f[I]${_value}")"
	fi
}
# }}} groff

# {{{ common
__join() {
	local _sep=$1; shift
	local _string=$1; shift
	while [ $# -ne 0 ]; do
		_string+=${_sep}$1
		shift
	done
	echo ${_string}
}

__filter_input() {
	sed 's/\\\([^_]\|$\)/\\e\1/g
		s/  / \\ /g
		s/'"'"'/\\[u0027]/g
		s/"/\\[u0022]/g
		s/`/\\[u0060]/g
		s/\$/\\[u0024]/g
	'
}
# }}} common

# {{{ markdown
__markdown() {
	local _cmd _id _value
	cat - <<-EOF
		# ${ADS_CMD_0[title]}
		## ${I18N[name]}
		${ADS_CMD_0[name]} - ${ADS_CMD_0[resume]}

		##  ${I18N[synopsis]}

		$(__markdown_synopsis)

		## Description
		${ADS_CMD_0[description]}

		$(if (( ${#ADS_CMDID[@]} > 1 )); then
			echo "## ${I18N[commands]}"
			for _id in ${ADS_CMDID[@]:1}; do
				local -n _cmd=${ADS_CMD[${_id}]}
				if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
					continue
				fi
				echo -n "### **${ADS_CMD_0[name]} ${_cmd[id]//./\\ }** "
				for _id in ${_cmd[options]}; do
					 __markdown_synopsis_opt ${ADS_OPT[${_id%%|*}]}
				done
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1      2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					echo "_${BASH_REMATCH[1]}_=_${BASH_REMATCH[4]}_"
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					_value=${BASH_REMATCH[1]#/}
					_value=${_value#\!/}
					_value=${_value%/}
					echo "_${_value}_"
				fi
				echo
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1       2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo "_${BASH_REMATCH[1]}_: ${BASH_REMATCH[3]//|/ | }"
						echo
					fi
					if (( ${#BASH_REMATCH[6]} > 0 )); then
						echo "_${BASH_REMATCH[4]}_: ${BASH_REMATCH[6]//|/ | }"
						echo
					fi
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo
						echo "_${BASH_REMATCH[1]}_: ${BASH_REMATCH[3]//|/ | }"
						echo
					fi
				fi
				echo "${_cmd[description]}"
				for _id in ${_cmd[options]}; do
					__markdown_opt ${ADS_OPT[${_id%%|*}]}
				done
			echo
			done
			echo
		fi)
		## Options
		$(for _id in ${ADS_CMD_0[options]}; do
			__markdown_opt ${ADS_OPT[${_id%%|*}]}
		done)
		$(test -n "${_cmd[author]}" && { echo $'## Author \n'"${_cmd[author]}"; })
		$(test -n "${_cmd[authors]}" && { echo $'## Authors\n'"${_cmd[authors]}"; })
		$(test -n "${_cmd[copyright]}" && { echo $'## Copyright\nÂ© '"${_cmd[copyright]}"; })
		$(test -n "${_cmd[copyleft]}" && { echo $'## Copyleft \nðŸ„¯ '"${_cmd[copyleft]}"; })
		$(test -n "${_cmd[licence]}" && { echo $'## Licence\n'"${_cmd[licence]}"; })
		$(test -n "${_cmd[license]}" && { echo $'## Licence\n'"${_cmd[license]}"; })
	EOF
}

__markdown_synopsis() {
	local _id _value _command _cmdid=$1
	echo -n " - **${ADS_CMD_0[name]}** "
	for _id in ${ADS_CMD_0[options]}; do
		__markdown_synopsis_opt ${ADS_OPT[${_id%%|*}]}
	done
	if (( ${#ADS_CMDID[@]} > 1 )); then
		echo -n "_command_ [_args_]"
		for _id in ${ADS_CMDID[@]:1}; do
			if (( ${#_cmdid} > 0 )) && [[ ! ${_id} =~ ^${_cmdid}$ ]]; then
				continue
			fi
			local -n _cmd=${ADS_CMD[${_id}]}
			if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
				continue
			fi
			_command="${ADS_CMD_0[name]} ${_cmd[id]//./ }"
			echo -n $'\n'" - **${_command}**"
			for _id in ${_cmd[options]}; do
				__markdown_synopsis_opt ${ADS_OPT[${_id%%|*}]}
			done
			#                        key=value
			#                        key(key constraint)=value(value constraint)
			#                        1      2  3        4      5  6
			if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
				_value=${BASH_REMATCH[4]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "_${BASH_REMATCH[1]}_=_${_value}_"
			#                          value
			#                          value(value constraint)
			#                          1      2  3
			elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
				_value=${BASH_REMATCH[1]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "_${_value}_"
			fi
		done
	fi
}

__markdown_synopsis_opt() {
	local _value
	local -n _opt=$1
	_value=${_opt[value]}
	#                        key=value
	#                        key(key constraint)=value(value constraint)
	#                        1       2  3        4       5  6
	if [[ ${_opt[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}=${BASH_REMATCH[4]}
	#                          value
	#                          value(value constraint)
	#                          1      2  3
	elif [[ ${_opt[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}
	fi

	_value=${_value#/}
	_value=${_value#\!/}
	_value=${_value%/}
	if ${_opt[requiered]}; then
		printf '**-%s**|**--%s**%s ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " _${_value}_")"
	else
		printf '[**-%s**|**--%s**%s] ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " _${_value}_")"
	fi
}

__markdown_opt() {
	local -n _opt=$1
	local _value _formated_value
	_value=${_opt[value]}
	if [ -n "${_value}" ]; then
		_value=${_value#/}
		_value=${_value#\!/}
		_value=${_value%/}
		_formated_value=" _${_value}_"
	fi
	cat - <<-EOF
		**--${_opt[name]}**${_formated_value}, **-${_opt[alias]}** ${_formated_value}
		$(echo "${_opt[description]}")

	EOF
}
# }}} markdown

# {{{ bash-completion
__bash-completion() {
	local _command=$1
	cat - <<-EOF
		_${_command// /-}_bash_completion() {
			local completion='$(__parse_cmdline --cmd-post-hook __bash_completion_commands --opt-hook __bash_completion_options)'
			local -A options

			for i in \$(seq 0 \$COMP_CWORD); do
				case "\${COMP_WORDS[\$i]}" in
					$(__parse_cmdline --cmd-post-hook __bash_completion_command --opt-hook __bash_completion_option)
				esac
			done
			COMPREPLY=( \$(compgen -o nospace -W "\${completion//  / }" -- \${COMP_WORDS[COMP_CWORD]}) )
			case "\${COMP_WORDS[COMP_CWORD - 1]}" in
				$(__parse_cmdline --opt-hook __bash_completion_value)
			esac
		}
		complete -F "_${_command// /-}_bash_completion" "${_command}" $@
	EOF
}

__bash_completion_value() {
	# /* file
	# /*/ directory
	# | separates a choice
	cat - <<-EOF
		-${short}|--${option})
		if [ "\$(type -t "_${cmd}_bash_complete_${option}")" = function ]; then
			_${cmd}_bash_complete_${option}
		else
	EOF
	if [ -n "${value}" ] && [ -z "${value%/*/}" ]; then
		cat - <<-EOF
			# Directory
			compopt -o nospace
			COMPREPLY=( \$(compgen -W "\$([ -d "\${COMP_WORDS[COMP_CWORD]}" ] && find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 -type d -printf '%p/\n' 2>/dev/null || find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 -type d -printf '%p/\n' 2>/dev/null)" -- \${COMP_WORDS[COMP_CWORD]}) )
		EOF
	elif [ -n "${value}" ] && [ -z "${value%/*}" ]; then
		cat - <<-EOF
			# File
			compopt -o nospace
			COMPREPLY=( \$(compgen -W "\$(find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 \( -type d -printf '%p/ ' , -type f -print \) 2>/dev/null)" -- \${COMP_WORDS[COMP_CWORD]}) )
		EOF
	elif [ -n "${value}" ] && [ -z "${value##*|*}" ]; then
		cat - <<-EOF
			# Choice
			COMPREPLY=( \$(compgen -W "${value//|/ }" -- \${COMP_WORDS[COMP_CWORD]} ) )
		EOF
	else
		cat - <<-EOF
			# Other
			true
		EOF
	fi
	cat - <<-EOF
			fi
			;;
	EOF
}

__bash_completion_options() {
	local -n _opt=$1
	echo -n "--${_opt[name]} "
}

__bash_completion_commands() {
	local -n _cmd=$1
	echo -n "${_cmd[name]} "
}

__bash_completion_option() {
	local -n _opt=$1
	${_opt[multi]} && return;
	cat - <<-EOF
		"-${_opt[alias]%%|*} "|"--${_opt[name]} ")
			completion=\${completion/--${_opt[name]} /}
	EOF
	if [ -z "${_opt[value]}" ]; then
		cat - <<-EOF
			options+=${_opt[alias]%%|*}
		EOF
	else
		cat - <<-EOF
			[ -n \"\${COMP_WORDS[\$i + 1]}\" ] && options+=${_opt[alias]%%|*}
		EOF
	fi
	cat - <<-EOF
		;;
	EOF
}

__bash_completion_command() {
	local -n _cmd=$1
	${_opt[multi]} && return;
	cat - <<-EOF
		"${_cmd[name]} ")
			completion=\${completion/${_cmd[name]} /}
			;;
	EOF
}
# }}} bash-completion

# {{{ debug
__debug_command() {
	local -n _command=$1
	local _opt _occurence _value

	if (( ${#_command[value]} > 0 )); then
		if   ${_command[requiered]} && ${_opt[multi]}; then _occurence=+
		elif ${_command[requiered]};                   then _occurence=!
		elif ${_command[multi]};                       then _occurence=*
		else                                                _occurence=?
		fi
		_value=" ${_occurence}${_command[value]}"
	fi
	echo "${_command[id]}${_value}: ${_command[description]}" >&2
	for _opt in ${_command[options]}; do
		__debug_option ${ADS_OPT[${_opt%%|*}]}
	done
}

__debug_option() {
	local -n _opt=$1
	local _occurence _value

	if   ${_opt[requiered]} && ${_opt[multi]}; then _occurence=+
	elif ${_opt[requiered]};                   then _occurence=!
	elif ${_opt[multi]};                       then _occurence=*
	else                                            _occurence=?
	fi
	if ((${#_opt[value]} > 0)); then
		_value=\ ${_opt[value]}
	fi

	echo "${_occurence}${_opt[id]}|${_opt[alias]}${_value}: ${_opt[description]}" >&2
}
# }}} debug

__init__ $@
